# 아키텍처

## MySQL

- ### 사람의 머리 역할을 담당하는 **MySQL엔진**
- ### 손발 역할을 담당하는 스토리지 **스토리지엔진**

## **MySQL 엔진 아키텍처**

<img src="./MySQL구조.png">

- MySQL 엔진

  - 클라이언트로부터의 접속 및 쿼리 요청을 처리하는 **커넥션 핸들러**
  - SQL 파서 및 전처리기, 쿼리의 최적화된 실행을 위한 **옵티마이저**

- 스토리지 엔진
  - 요청된 SQL 문장을 분석 및 최적화
  - 데이터를 디스크 스토리지에 저장하고 읽기를 담당
  - 스토리지 엔진 다중 사용 가능함
    - 핸들러 API를 만족하는 스토리지 엔진을 추가할 수 있음

> 핸들러 API?
> MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진에 쓰기 또는 읽기를 요청하는데,
> 이러한 요청을 **핸들러** 요청이라하고, 여기서 사용되는 API를 **핸들러 API**라고 합니다.

### **MySQL 스레딩 구조**

<img src="./MySQL스레딩모델.png">

- MySQL 서버는 스레드 기반으로 작동

  - 포그라운드 스레드

    - 사용자가 요청하는 쿼리 문장을 처리함
    - 데이터를 데이터 버퍼나 캐시로부터 가져옴
    - 버퍼나 캐시에 없는 경우 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리함

  - 백그라운드 스레드
    - 로그 스레드
    - 쓰기 스레드
      - 버퍼의 데이터를 디스크로 내려쓰는 작업을 처리함

---

- **MyISAM 테이블**: **포그라운드 스레드**가 디스크 쓰기 작업까지 처리함,

  - 일반적인 쿼리는 쓰기 버퍼링 기능을 사용할 수 없다.
  - 사용자가 INSERT, UPDATE, DELETE 쿼리가 처리될 때까지 기다려야 함

- **innoDB 테이블**: 데이터 버퍼나 캐시까지 처리함, 나머지 버퍼로부터 디스크까지 기록하는 작업은 **백그라운드 스레드**가 처리함
  - 인서트 버퍼(insert Buffer)를 병합하는 스레드
  - 로그를 디스크로 기록하는 스레드
  - innoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
  - 데이터를 버퍼로 읽어오는 스레드
  - 잠금이나 데드락을 모니터링하는 스레드

### **메모리 할당 및 사용 구조**

- 글로벌 메모리 영역
  - 클라이언트 스레드 수와 무관하게 하나의 메모리 공간만 할당됨
    - 필요에 따라 2개 이상의 메모리 공간을 할당가능함
  - 모든 스레드에 의해 공유됨
- 로컬 메모리 영역
  - 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역임
  - 각 클라이언트 스레드별로 독립 할당됨(서로 공유X)

### **플러그인 스토리지 엔진 모델**

- 사용자 인증 방식, 검색 엔진, 스토리지 엔진 등을 플러그인 형태로 개발해서 사용 가능
  - 수많은 사용자의 요구 조건을 만족시키기 위함

### **컴포넌트**

- 기존 플로그인 아키텍처를 대체하기 위해 컴포넌트 아키텍처를 지원함
- 플러그인의 단점을 보완해서 구현됨
  - 플로그인의 단점
    - 오직 MySQL 서버와 통신 가능
    - MySQL 서버의 변수나 함수를 직접 호출(캡슐화X)
    - 상호 의존 관계를 설정할 수 없어서 초기화가 어려움

### **쿼리 실행 구조**

_쿼리 파서_

- 사용자 요청을 토큰화하고, 트리 형태의 구조로 만듦
- 쿼리 문장의 기본 문법 오류를 체크함

_전처리기_

- 파서 과정에서 만들어진 트리기반 쿼리 문장에 구조적인 문제점 체크
- 각 토큰의 테이블 이름, 칼럼 이름, 또는 내장 함수와 같으 개체를 매핑함
  - 해당 객체의 존재 여부와 객체의 접근 권한 등을 확인함

_옵티마이저_

- 사용자의 요청으로 들어온 쿼리를 가장 저렴한 비용으로 가장 빠르게 처리할지를 결정하는 역할

_실행 엔진_

- 만들어진 계획대로 각 핸들러에 요청하고 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할

_핸들러(스토리지 엔진)_

- 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 읽어오는 역할을 담당함
- 핸들러는 스토리지 엔진을 의미함

### **쿼리 캐시**

- SQL의 실행 결과를 메모리에 캐시함
  - 동일한 SQL 요청에 매루 빠른 성능
  - 하지만 테이블의 데이터 변경 시 캐시에 저장된 데이터 중 관련된 데이터를 전부 삭제해야 함 (성능 저하 유발)
  - MySQL 8.0 이후 삭제된 기능

### **스레드 풀**

- 내부적으로 사용자 요청을 처리하는 스레드 개수를 줄이고, MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게 해서 서버의 자원 소모를 줄이는 것이 목적임

### **트랜잭션 지원 메타데이터**

테이블 구조 정보나 스토어드 프로그램 코드 관전 정보를 InnoDB의 테이블에 저장함

## **InnoDB 스토리지 엔진 아키텍처**

### InnoDB

- 레코드 기반의 잠금을 제공
  - 높은 동시성 처리에 안정적이며 성능이 뛰어남
- 프라이머리 키에 의한 클러스터링

  > **클러스터링이란 ?**  
  > 개체들을 분류(classification)하기 위한 기준이 없는 상태에서 주어진 데이터의 속성값들을 고려해 유사한 개체끼리 그룹(클러스터)화하는 방법이다. 그룹내 차이를 줄이고 그룹간 차이는 최대화 하도록 하여 대표성을 찾는 원리로 구현되는 것이 일반적이다.

  - 모든 테이블은 프라이머리 키를 기준으로 클러스터링 되어 저장됨
    - 프라이머리 키를 이용한 레인지 스캔이 빠르다.
    - > **레인지 스캔이란?**  
      > 인덱스 루트 블록에서 리프 블록까지 수직적으로 탐색한 후에 리프 블록을 필요한 범위만 스캔하는 방식  
      > 참고: [다양한 인덱스 스캔 방식](http://wiki.gurubee.net/pages/viewpage.action?pageId=26739956)
  - 모든 세컨터리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용함

- 외래 키 지원
- MVCC(Multi Version Concurrency Control)
- 잠금을 사용하지 않는 일관된 읽기를 제공
  - InnoDB에서 읽기 작업은 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고, 읽기 작업이 가능함
    - 격리 수준이 SERIALIZABLE이 아닌 READ_UNCOMMITTED나 READ_COMMITTED, REPEATALBE_READ 수준인 경우 INSERT와 연결되지 않은 순수한 읽기(SELECT)작업은 잠금을 대기하지 않고 바로 실행됨
- 자동 데드락 감지

  - 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프(Wait-for List)형태로 관리함
  - 교착 상태에 빠진 트랜잭션들이 있다면, 그중 하나를 강제 종료함
    - 언두 로그의 양으로 어느 트랜잭션을 강제 종료할 것인가를 결정함
  - 동시 처리 스레드가 매우 많아지거나 각 트랜잭션이 가진 잠금의 개수가 많아지면 데드락 감지 스레드는 더 많은 CPU 자원을 소모하고 처리 속도도 느려진다.
    - MySQL 서버는 innodb_deadlock_detect 시스템 변수를 제공하며, innodb_deadlock_detect를 OFF로 설정하면 데드락 감지 스레드는 작동하지 않는다.
    - 대신 데드락이 발생하면 누군가가 중재를 하지 않기 때문에 무한정 대기하게 된다.
    - innodb_lock_wait_timeout을 기본값인 50초보다 훨씬 낮은 시간으로 설정해, 자동으로 요청이 실패하고 에러를 반환하게 한다.

- 자동화된 장애 복구

  - InnoDB 데이터 파일은 기본적으로 MySQL서버가 시작될 때 항상 자동 복구 수행함

- InoDB 버퍼 풀
  - 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간
  - 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할
  - 구조
    - 버퍼 풀이라는 거대한 메모리 공간을 innodb_page_size 변수 크기의 페이지 조각으로 쪼개어 스토리지 엔진이 데이터를 필요로 할 때 해당 데이터 페이지를 읽어서 각 조각에 저장함
    - 페이지 조각 관리를 위해 LRU 리스트, 플러시(Flush) 리스트, 프리(Free) 리스트라는 자료 구조를 관리함
  - 데이터베이서 서버의 성능 향상을 위해 데이터 캐시와 쓰기 버퍼링이라는 두 가지 용도가 있음
