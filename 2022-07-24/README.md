## 클러스터링 인덱스

> **클러스터링이란?**  
> 여러 개를 하나로 묵는다는 의미로 사용되는데, 주어진 데이터들이 얼마나, 어떻게 유사한 지에 따라 데이터셋을 요약, 정하는 것이다.

### **클러스터링 인덱스**

MySQL 서버에서 클러스터링은 테이블의 레코드를 비슷한 것(프라이머리 키를 기준으로)들 끼리 묶어서 저장하는 형태로 구현한다.  
이는 주로 비슷한 값들이 동시에 조회하는 경우가 많다는 점에서 착안한 것이다.
MySQL 에서 클러스터링 인덱스는 InnoDB 스토리지 엔진에서만 지원한다.

클러스터링 인덱스는 테이블의 프라이머리 키에 대해서만 적용되는 내용이다. 즉 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 **클러스터링 인덱스**라고 표현한다.

- 프라이머리 키 값에 의해 레코드의 저장 위치가 결정된다.

  - 클러스터링 인덱스는 인덱스 알고리즘이라기보다 테이블 레코드의 저장 방식이라 볼 수 있다.

- 프라이머리 카 값이 변경된다면 레코드의 물리적인 저장 위치가 바뀌어야 한다.
- 프라이머리 키 값으로 클러스터링된 테이블은 프라이머리 키 값 자체에 대한 의존도가 상당히 크기 때문에 신중히 프라이머리 키를 결정해야한다.
- 프라이머리 키 기반의 검색이 매우 빠르며, 대신 레코드의 저장이나 키의 변경이 상대적으로 느리다.

> _주의_  
> 일반적으로 B-Tree 인덱스도 인덱스 키 값으로 이미 정렬되어 저장된다. 하지만 B-Tree를 클러스터링 인덱스라고 부르지 않는다.  
> 테이블의 레코드가 프라이머리 키 값으로 정렬되어 저장된 경우만 "클러스터링 인덱스" 또는 "클러스터링 테이블"이라고 한다.

**프라이머리 키가 없다면?**  
프라이머리 키가 없는 경우 InnoDB 스토리지 엔진은 프라이머리 키를 대체할 칼럼을 선택한다.

1. NOT NULL 옵션의 유니크 인덱스(UNIQUE INDEX) 중에서 첫 번째 인덱스
2. 자동으로 유니크한 값을 가지도록 증가하는 칼럼을 내부적으로 추가
   - 이 경우 아무 의미 없는 숫자 값으로 크럴스터링 되는 것이며, 우리에게 아무런 혜택을 주지 않는다.
   - 클러스터링 인덱스는 테이블당 단 하나만 가질 수 있는 엄청난 혜택이므로 가능하다면 프라이머리 키를 명시적으로 생성해야 한다.

### **세컨더리 인덱스에 미치는 영향**

InnoDB에서 세컨더리 인덱스가 실제 레코드 주소를 가지고 있다면, 클러스터링 키 값이 변경될 때마다 레코드의 주소가 변경되는 특성 때문에 테이블의 모든 인덱스에 저장된 주솟값을 변경해야 할 것이다. 때문에 InnoDB 테이블(클러스터링 테이블)의 모든 세컨더리 인덱스는 해당 레코드의 주소가 아니라 프라이머리 키 값을 저장하도록 구현되어 있다.

### **클러스터링 인덱스의 장점과 단점**

- 장점
  - 프라이머리 키(클러스터링 키)의 검색 처리 성능이 매우 빠름(특히, 프라이머리 키를 범위 검색하는 경우)
  - 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음
- 단점
  - 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링의 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커짐
  - 세컨터리 인덱스를 통해 검색할 때 프라이머리 키로 다시 한번 검색해야 하므로 처리 성능이 느림
  - INSERT할 때 프라이머리 키에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림
  - 프라이머리 키를 변경할 때 레코드를 DELETE하고 INSERT하는 작업이 필요하기 때문에 처리 성능이 느림
- 요약
  - 클러스터링 인덱스의 장점은 빠른 읽기, 단점은 느림 쓰기
  - 일반적인 웹 서비스와 같은 온라인 트랜잭션 환경에서는 쓰기와 읽기의 비율이 2:8 또는 1:9 정도이기 때문에 조금 느린 쓰기를 감수하고 읽기를 빠르게 유지하는 것이 매우 중요하다.

### **클러스터링 테이블 사용 시 주의사항**

- 클러스터링 인덱스 키의 크기에 따라 인덱스 크기가 달라진다.
- 프라이머리 키에 따라 레코드의 위치가 결정된다. 따라서 AUTO-INCREMENT 보다 업무적인 칼럼(해당 레코드를 대표할 수 있는 칼럼)으로 생성해야 한다.
- 프라이머리 키는 반드시 명시해야 함.
- 여러 개의 칼럼이 복합으로 프라이머리 키가 만들어지는 경우 프라이머리 키의 크기가 길어질 때 AUTO-INCREMENT 칼럼을 인조 식별자로 사용할 수 있다.
  - 로그 테이블과 같이 조회보다는 INSERT 위주의 테이블들은 AUTO-INCREMENT를 이용한 인조 식별자를 프라이머리 키로 설정하는 것이 성능 향상에 도움이 된다.

## 유니크 인덱스

유니크는 테이블이나 인덱스에 같은 값이 2개 이상 저장될 수 없음을 의미한다. (인덱스라기보다는 제약 조건에 가깝다고 볼 수 있다.)

MyISAM이나 MEMORY 테이블에서 프라이머리 키는 NULL이 허용되지 않는 유니크 인덱스와 같지만, InnoDB 테이블의 프라이머리 키는 클러스터링 키의 역할도 하므로 유니크 인덱스와는 근복적으로 다르다.

### **유니크 인덱스와 일반 세컨더리 인덱스의 비교**

유니크 인덱스와 유니크하지 않은 일반 세컨더리 인덱스는 사실 인덱스의 구조상 아무런 차이점이 없다.

- 인덱스 읽기
  - 유니크 인덱스와 세컨더리 인덱스는 성능상 거의 차이가 없다.
  - 유니크 하지 않은 세컨더리 인덱스는 중복된 값이 허용되므로 읽어야 할 레코드가 많아서 느린 것이지, 인덱스 자체의 특성 떄문에 느린 것이 아니다.
  - 읽어야 할 레코드 건수가 같다면 성능상의 차이는 미미하다.
- 인덱스 쓰기
  - 유니크 인덱스의 키 값을 쓸 때는 중복된 값이 있는지 없는지 체크하는 과정이 한 단계 더 필요하다. 그래서 유니크하지 않은 세컨더리 인덱스의 쓰기보다 느리다.
  - MySQL에서는 유니크 인덱스의 중복된 값을 체크할 때는 읽기 잠금을 사용하고, 쓰기를 할 때는 쓰기 잠금을 사용하는데 이 과정에서 데드락이 아주 빈번히 발생한다.
  - InnoDB 스토리지 엔진에서는 인덱스 키의 저장을 버퍼링하기 위해 체인지 버퍼(Change Buffer)가 사용된다. 그래서 인덱스의 저장이나 변경 작업이 상당히 빨리 처리되지만, 유니크 인덱스는 중복 체크를 해야 함으로 작업 자체를 버퍼링하지 못한다. 이 때문에 유니크 인덱스는 일반 세컨더리 인덱스보다 변경 작업이 더 느리게 작동한다.

### **외래키**

MySQL에서 외래키는 InnoDB 스토리지 엔진에서만 생성할 수 있으며, 외래키 제약이 설정되면 자동으로 연관되는 테이블의 칼럼에 인덱스까지 생성된다. 외래키가 제거되지 않은 상태에서는 자동으로 생성된 인덱스를 삭제할 수 없다.

InnoDB의 외래키 관리에 중요한 특징

- 테이블의 변경(쓰기 잠금)이 발생하는 경우에만 잠금 경합(잠금 대기)이 발생한다.
  - 자식 테이블의 외래 키 칼럼의 변경은 부모 테이블의 확인이 필요한데, 이 상태에서 부모 테이블의 해당 레코드가 쓰기 잠금이 걸려 있으면 해당 쓰기 잠금이 해제될 때까지 기다리게 되는 것이다.
- 외래키와 연관되지 않은 칼럼의 변경은 최대한 잠금 경합(잠금 대기)을 발생시키지 않는다.
  - 자식 테이블의 외래키가 아닌 칼럼의 변경은 외래키로 인한 잠금 확장이 발생하지 않는다.

물리적으로 외래키를 생성하면 자식 테이블에 레코드가 추가되는 경우 해당 참조키가 부모 테이블에 있는지 확인한다. 외래 키를 생성할 때 고려 사항은 이를 체크하기 위해 연관 테이블에 읽기 잠금을 걸어야 한다는 것이다. 이렇게 잠금이 다른 테이블로 확장되면 그만큼 전체적으로 쿼리의 동시 처리에 영향을 미치기 때문이다.

# 옵티마이저와 힌트

MySQL는 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떤 분포로 저장돼 있는지 통계 정보를 참조하며, 그러한 기본 데이터를 비교해 최적의 실행 계획을 수립하는 작업이 필요하다. 이를 옵티마이저가 담당한다.

옵티마이저가 만들어 내는 실행 계획을 이해하는 것은 어려운 부분이다. 하지만 이를 이해할 수 있어야만 실행 계획의 불합리한 부분을 찾아내고, 더 최적화된 방법으로 실행 계획을 수립하도록 유도할 수 있다.

### 쿼리 실행 절차

1. 사용자로부터 요청된 SQL 문장을 잘개 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리)한다.
   - 이 단계를 "SQL 파싱(Parsing)"이라고 함
   - MySQL 서버의 "SQL 파서"라는 모듈로 처리 함
   - 쿼리의 SQL 문법을 체크 함
2. SQL의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
   - 이 단계를 "최적화 및 실행 계획 수립"이라고 함
   - MySQL 서버의 "옵티마이저"에서 처리 함
   - 처리 내용
     - 불필요한 조건 제거 및 복잡한 연산의 단순화
     - 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
     - 각 테이블에 사용돈 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정
     - 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정
3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.

### **옵티마이저의 종류**

- 규칙 기반 최적화(Rule-based optimizer, RBO)
  - 기본적으로 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식을 의미함
  - 같은 쿼리에 대해서 거의 항상 같은 실행 방법을 만듦
  - 사용자의 데이터는 분포도가 매우 다양하기 때문에 DBMS에서 거의 사용되지 않음
- 비용 기분 최적화(Cost-based optimizer, CBO)
  - 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고, 각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출해 비용이 최소인 처리 방식을 선택해 쿼리를 실행함

## 기본 데이터 처리

모든 RDBMS는 데이터를 정렬하거나 그루핑하는 등의 기본 데이터 가공 기능을 가지고 있다. RDBMS별로 결과를 만들어 내는 과정은 천차만별이다. MySQL 서버는 어떤 알고리즘을 사용할까

### **풀 테이블 스캔과 풀 인덱스 스캔**

- 풀 테이블 스캔
  - 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업을 의미함
  - 사용 조건
    - 테이블의 레코드 건수가 작아 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 빠른 경우(일반적으로 테이블이 페이지 1개로 구성된 경우)
    - WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
    - 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우(B-Tree를 샘플링해서 조사한 통계 정보 기준)
  - InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드(Read ahead) 작업이 자동으로 시작됨
    - 리드 어헤드란 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 것을 의미함
  - 즉, 풀 테이블 스캔이 실행되면 처음 몇 개의 데이터 페이지는 포그라운드 스레드(Foreground thread, 클라이언트 스레드)가 페이지 읽기를 실행하지만 특정 시점부터는 읽기 작업을 백그라운드 스레드로 넘김
  - 백그라운드 스레드가 읽기를 넘겨받는 시점부터는 한 번에 4개 또는 8개씩의 페이지를 읽으면서 계속 그 수를 증가 시킴 이때 62개의 데이터 페이지까지 읽어서 버퍼 풀에 저장해 둠
  - 포그라운드 스레드는 미리 버퍼 풀에 준비된 데이터를 가져다 사용하기만 하면 되므로 쿼리가 상당히 빨라짐
  - MySQL 서버에서는 _innodb_read_ahead_threshold_ 시스템 변수를 이용해 InnoDB 스토리지 엔진이 언제 리드 어헤드를 시작할지 임계 값을 설정할 수 있음

### **병렬 처리**

MySQL 8.0 버전부터 용도가 한정돼 있긴 하지만 처음으로 MySQL 서버에서도 쿼리의 병렬 처리(하나의 쿼리를 여러 스레드가 작업을 나누어 동시에 처리하는 것)가 가능해졌다.

_innodb_parallel_read_threads_ 시스템 변수를 이용해 하나의 쿼리를 최대 몇 개의 스레드를 이용해 처리할지를 변경할 수 있다.  
아직 MySQL 8.0 버전에는 아무런 WHERE 조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리만 병렬로 처리 가능하다.

### **ORDER BY 처리(Using filesort)**

정렬을 처리하는 방법

- 인덱스 이용
  - 장점
    - INSERT, UPDATE, DELETE 쿼리가 실행될 때 이미 인덱스가 정렬돼 있어서 매우 빠름
  - 단점
    - INSERT, UPDATE, DELETE 작업 시 부가적인 인덱스 추가/삭제 작업이 필요함
    - 인덱스 때문에 디스크 공간이 더 많이 필요함
    - 인덱스 개수가 늘어날수록 InnoDB의 버퍼 풀을 위한 메모리가 많이 필요함
  - 인덱스를 이용하지 못하는 경우
    - 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
    - GROUP BY의 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야 하는 경우
    - UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
    - 랜덤하게 결과 레코드를 가져와야 하는 경우
- Filesort 이용
  - 장점
    - 인덱스를 생성하지 않아도 됨, 인덱스 이용의 단점이 장점이 됨
    - 정렬해야 할 레코드가 많지 않다면 메모리에서 처리되므로 빠름
  - 단점
    - 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느림

MySQL의 정렬 특성을 이해하면 쿼리를 튜닝할 때 어떻게 하면 조금이라도 더 빠른 쿼리가 될지 판단할 수 있을 것이다.
